#!/bin/bash


#### /tmp/fullName proviene da ricorsivo6.sh ed è il nome del file completo ossia
### avente percorso ed estensione.
### /tmp/fullName serve anche 6a.edr


####### preparazione dei comandi


#echo ":1s/\// /g
#ZZ
#
#" > /tmp/sostSlashBlank



#echo ":1s/ /\//g
#ZZ
#
#" > /tmp/sostBlankWithSlash



cp /tmp/fullName /tmp/fullNameBackup


sed 's/[^/]//g' /tmp/fullName | awk '{ print length }' > /tmp/countSlash


leggoCountSlash=$(cat /tmp/countSlash)

if test $leggoCountSlash == 0
then

vi -s /usr/local/lib/pdflux/sostSlashBlank /tmp/fullName


################### devo isolare il percorso
### Leggo il numero di livello del file attraverso le << / >>
### definisco esso numberOfColumn anche se il reale numero di colonne è pari al numero di << / >> più 1 ma 
### a me non interessa includere la colonna del file ma solo il numero di colonne del suo percorso, per 
### isolare quest'ultimo.
# vedi tools-utility/scripting/count/counting-character/ per la spiegazione
sed 's/[^/]//g' /tmp/fullNameBackup | awk '{ print length }' > /tmp/colC.txt


numberOfcolumn=$(cat /tmp/colC.txt)




################### devo isolare il percorso


######## Tale sezione di bc non mi serve più perché devo compensare in awk per non aver problemi di virgole.
### So che i campi che mi isolano il percorso ossia mi privano dell'ultima cartella (se l'oggetto di tale script è una cartella)
### o del nome del file (se l'oggetto di tale script è un file)
## sono pari a $leggoNumeroDirectory - 2 ossia meno l'ultimo campo quello di interesse.

echo $numberOfcolumn - 2| bc > /tmp/colonnePathIsolato


#################################### TEST

### read -p "Ha stampato /tmp/colonnePathIsolato ?" EnterNull

####################################


leggoColonne=$(cat /tmp/colonnePathIsolato)

### mi serve un ciclo per automatizzare ciò
## so con cat /tmp/colonnePathIsolato che il numero di colonne è pari a 3
## quindi devo creare cat /tmp/fullName | awk '$1 > 0 {print $1,$2,$3}'

########## Composizione

echo "cat /tmp/fullName | awk '\$1 > 0 {print " > /tmp/Ipezzo.txt


######## devo evitare la << , >> che creo con la prima var, quindi alla fine non devo avere ,$1
#### ecco perché mi serve il condizionale e rimuovere se esiste il pregresso /tmp/IIpezzo.txt
## E`importante assicurarsi che non esista /tmp/IIpezzo.txt sia ora che dopo.


echo "#!/bin/bash

declare -i var=0

for i in {1..$leggoColonne}
 do
  var=\$var+1
  if [ -f /tmp/IIpezzo.txt ]; then
      echo \",\\$\$var\" > /tmp/IIpezzo.txt
     cat /tmp/Ipezzo.txt /tmp/IIpezzo.txt > /tmp/pezzoTot.txt
     cat /tmp/pezzoTot.txt  |tr -d '\n' > /tmp/preIstanzaAwk.txt
     cp /tmp/preIstanzaAwk.txt /tmp/Ipezzo.txt
   else
     echo \"\\$\$var\" > /tmp/IIpezzo.txt
     cat /tmp/Ipezzo.txt /tmp/IIpezzo.txt > /tmp/pezzoTot.txt
     echo \",\\$\$var\" > /tmp/IIpezzo.txt
     cat /tmp/pezzoTot.txt  |tr -d '\n' > /tmp/preIstanzaAwk.txt
     cp /tmp/preIstanzaAwk.txt /tmp/Ipezzo.txt
  fi
done

rm  /tmp/IIpezzo.txt /tmp/pezzoTot.txt


exit

" > cicloPerAwk.sh

chmod ug+x cicloPerAwk.sh


./cicloPerAwk.sh

rm cicloPerAwk.sh

echo "}' > /tmp/percorsoBlanked" > /tmp/chiusuraIstanzaAwk


cat /tmp/Ipezzo.txt /tmp/chiusuraIstanzaAwk |tr -d '\n' > /tmp/istanzaAwk

echo "#!/bin/bash

" > /tmp/intestazione.edr

cat /tmp/intestazione.edr /tmp/istanzaAwk > azioneAwk.sh

echo "

exit

" >> azioneAwk.sh

chmod ug+xr azioneAwk.sh

./azioneAwk.sh

rm azioneAwk.sh



####### Siccome il file è nella stessa posizione del terminale 
####### allora non devo presentare il file /tmp/percorsoIsolato altrimenti
####### /usr/local/lib/pdflux/B/B3/2/1b.edr non funziona.


#vi -s /usr/local/lib/pdflux/sostBlankWithSlash /tmp/percorsoBlanked

#echo "/" > /tmp/prefisso

##### percorso isolato serve a 6d.edr per piazzare i file *.pdf nella loro posizione di origine 

#cat /tmp/prefisso /tmp/percorsoBlanked |tr -d '\n' > /tmp/percorsoIsolato






#cd $leggoPathIsolato

################################################################# verifiche test
#echo "questo è il percorso giusto $leggoPathIsolato ?" 


######### Leggo il file o la cartella oggetto di interesse


cat /tmp/fullName | awk '$1 > 0 {print $'$numberOfcolumn'}' > /tmp/nomeFileIsolato


cp /tmp/nomeFileIsolato /tmp/nomeFileIsolatoConPunti

###### nome del file senza estensione

#### creo i campi di qwk creando lo spazio tra nome ed estensione
vi -s /usr/local/lib/pdflux/command-sost-pto /tmp/nomeFileIsolato

## il I campo è il nome senza estensione

cat /tmp/nomeFileIsolato | awk '$1 > 0 {print $1}' > /tmp/nomeSenzaEstensione


## in /usr/local/lib/pdflux/B/B2/4ricorsivoSingoli/6/6a.edr devo leggere /tmp/nomeSenzaEstensione
## per avere come output lo stesso nome dell'input ma con estensione *.pdf.




else


vi -s /usr/local/lib/pdflux/sostSlashBlank /tmp/fullName


################### devo isolare il percorso
### Leggo il numero di livello del file attraverso le << / >>
### definisco esso numberOfColumn anche se il reale numero di colonne è pari al numero di << / >> più 1 ma 
### a me non interessa includere la colonna del file ma solo il numero di colonne del suo percorso, per 
### isolare quest'ultimo.
# vedi tools-utility/scripting/count/counting-character/ per la spiegazione
sed 's/[^/]//g' /tmp/fullNameBackup | awk '{ print length }' > /tmp/colC.txt


numberOfcolumn=$(cat /tmp/colC.txt)




################### devo isolare il percorso


######## Tale sezione di bc non mi serve più perché devo compensare in awk per non aver problemi di virgole.
### So che i campi che mi isolano il percorso ossia mi privano dell'ultima cartella (se l'oggetto di tale script è una cartella)
### o del nome del file (se l'oggetto di tale script è un file)
## sono pari a $leggoNumeroDirectory - 1 ossia meno l'ultimo campo quello di interesse.

echo $numberOfcolumn - 1| bc > /tmp/colonnePathIsolato


#################################### TEST

### read -p "Ha stampato /tmp/colonnePathIsolato ?" EnterNull

####################################


leggoColonne=$(cat /tmp/colonnePathIsolato)

### mi serve un ciclo per automatizzare ciò
## so con cat /tmp/colonnePathIsolato che il numero di colonne è pari a 3
## quindi devo creare cat /tmp/fullName | awk '$1 > 0 {print $1,$2,$3}'

########## Composizione

echo "cat /tmp/fullName | awk '\$1 > 0 {print " > /tmp/Ipezzo.txt


######## devo evitare la << , >> che creo con la prima var, quindi alla fine non devo avere ,$1
#### ecco perché mi serve il condizionale e rimuovere se esiste il pregresso /tmp/IIpezzo.txt
## E`importante assicurarsi che non esista /tmp/IIpezzo.txt sia ora che dopo.


echo "#!/bin/bash

declare -i var=0

for i in {1..$leggoColonne}
 do
  var=\$var+1
  if [ -f /tmp/IIpezzo.txt ]; then
      echo \",\\$\$var\" > /tmp/IIpezzo.txt
     cat /tmp/Ipezzo.txt /tmp/IIpezzo.txt > /tmp/pezzoTot.txt
     cat /tmp/pezzoTot.txt  |tr -d '\n' > /tmp/preIstanzaAwk.txt
     cp /tmp/preIstanzaAwk.txt /tmp/Ipezzo.txt
   else
     echo \"\\$\$var\" > /tmp/IIpezzo.txt
     cat /tmp/Ipezzo.txt /tmp/IIpezzo.txt > /tmp/pezzoTot.txt
     echo \",\\$\$var\" > /tmp/IIpezzo.txt
     cat /tmp/pezzoTot.txt  |tr -d '\n' > /tmp/preIstanzaAwk.txt
     cp /tmp/preIstanzaAwk.txt /tmp/Ipezzo.txt
  fi
done

rm  /tmp/IIpezzo.txt /tmp/pezzoTot.txt


exit

" > cicloPerAwk.sh

chmod ug+x cicloPerAwk.sh


./cicloPerAwk.sh

rm cicloPerAwk.sh

echo "}' > /tmp/percorsoBlanked" > /tmp/chiusuraIstanzaAwk


cat /tmp/Ipezzo.txt /tmp/chiusuraIstanzaAwk |tr -d '\n' > /tmp/istanzaAwk

echo "#!/bin/bash

" > /tmp/intestazione.edr

cat /tmp/intestazione.edr /tmp/istanzaAwk > azioneAwk.sh

echo "

exit

" >> azioneAwk.sh

chmod ug+xr azioneAwk.sh

./azioneAwk.sh

rm azioneAwk.sh





vi -s /usr/local/lib/pdflux/sostBlankWithSlash /tmp/percorsoBlanked

echo "/" > /tmp/prefisso

##### percorso isolato serve a 6d.edr per piazzare i file *.pdf nella loro posizione di origine 

cat /tmp/prefisso /tmp/percorsoBlanked |tr -d '\n' > /tmp/percorsoIsolato






#cd $leggoPathIsolato

################################################################# verifiche test
#echo "questo è il percorso giusto $leggoPathIsolato ?" 


######### Leggo il file o la cartella oggetto di interesse


cat /tmp/fullName | awk '$1 > 0 {print $'$numberOfcolumn'}' > /tmp/nomeFileIsolato


cp /tmp/nomeFileIsolato /tmp/nomeFileIsolatoConPunti
###### nome del file senza estensione

#### creo i campi di qwk creando lo spazio tra nome ed estensione
vi -s /usr/local/lib/pdflux/command-sost-pto /tmp/nomeFileIsolato

## il I campo è il nome senza estensione

cat /tmp/nomeFileIsolato | awk '$1 > 0 {print $1}' > /tmp/nomeSenzaEstensione


## in /usr/local/lib/pdflux/B/B2/4ricorsivoSingoli/6/6a.edr devo leggere /tmp/nomeSenzaEstensione
## per avere come output lo stesso nome dell'input ma con estensione *.pdf.

fi





exit


